using System;
using System.Collections.Generic;
using System.Text;

namespace D_OOP.Classes.Polymorphism
{
    abstract class  Shapes //Полиморфизм, так же объявляем abstract в декларацию класса
    {
        //Объявим 3 абстрактных метода. Абстрактные методы не имеют фигурных скобок и не имеют реализации вообще
        public abstract void Draw();  //abstract абстрактный метод Это и есть контракт, описание сигнатуры

        public abstract double Area();//Возвращает площадь

        public abstract double Perimeter(); //Периметр

        public Shapes() //конструктор Если в базовом классе у конструктора есть аргументы в скобках, то в классах наследниках в 
            //их конструкторах необходимо указывать : base("аргумент")
        {
            Console.WriteLine("Shape created"); //форма создана
        }
        /*Абстрактные члены могут быть только в абстрактном класса, А экземпляр абстрактного класса создан быть не может
         Абстрактные методы не имеют фигурных скобок и не имеют реализации. Наследники будут обязаны переопределять эти методы
         Если хотя бы 1 метод в классе-наследнике не будет переопределен - код не скомпилируется
        
        Так как мы переопределили все эти методы, вызывающий код может унифицированно работать со всеми этими типами/классами
         * используя базовый класс/абстрактный, записать экземпляр абстрактного класса можно в виде массива и передать туда наши 
          * классы - наследники в этот массив.
        Мы не можем создавать экземпляры абстрактных классов, но мы можем создавать массив Shapes        
         Shapes[] shapes = new Spapes[2];
         shapes[0] = new Triangle(6.3, 8.2, 9.7);
         Можно работать с наследниками, использовав базовый класс*/
    }
}
